use crate::codegen::SchemaRegistry;
use crate::schema::{LiteralValue, Schema};
use handlebars::Handlebars;
use serde::Serialize;
use std::collections::HashMap;

pub struct TypeScriptGenerator {
    registry: Handlebars<'static>,
}

impl TypeScriptGenerator {
    pub fn new() -> Self {
        let mut registry = Handlebars::new();
        registry
            .register_template_string("module", MODULE_TEMPLATE)
            .unwrap();
        registry
            .register_template_string("interface", INTERFACE_TEMPLATE)
            .unwrap();
        registry
            .register_template_string("enum", ENUM_TEMPLATE)
            .unwrap();
        registry
            .register_template_string("type", TYPE_TEMPLATE)
            .unwrap();

        Self { registry }
    }

    pub fn generate(&self, name: &str, schema: &Schema) -> Result<String, crate::Error> {
        let context = SchemaContext::from_schema(name, schema);

        match schema {
            Schema::Enum { values } => {
                let ctx = EnumContext {
                    name: name.to_string(),
                    values: values.clone(),
                };
                Ok(self.registry.render("enum", &ctx)?)
            }
            Schema::Object { .. } => Ok(self.registry.render("interface", &context)?),
            Schema::Union { .. } => {
                let ts_type = schema_to_ts_type(schema, &HashMap::new());
                let ctx = TypeContext {
                    name: name.to_string(),
                    ts_type,
                };
                Ok(self.registry.render("type", &ctx)?)
            }
            Schema::Named { schema, .. } => self.generate(name, schema),
            _ => {
                let ts_type = schema_to_ts_type(schema, &HashMap::new());
                let ctx = TypeContext {
                    name: name.to_string(),
                    ts_type,
                };
                Ok(self.registry.render("type", &ctx)?)
            }
        }
    }

    pub fn generate_module(&self, registry: &SchemaRegistry) -> Result<String, crate::Error> {
        let mut rendered: Vec<String> = Vec::new();

        for (name, schema) in registry.schemas() {
            rendered.push(self.generate(name, schema)?);
        }

        let mut output = String::new();
        output.push_str("// Auto-generated by typebox-rs. DO NOT EDIT.\n\n");

        for code in rendered {
            output.push_str(&code);
            output.push_str("\n");
        }

        Ok(output)
    }
}

impl Default for TypeScriptGenerator {
    fn default() -> Self {
        Self::new()
    }
}

#[derive(Serialize)]
struct SchemaContext {
    name: String,
    description: Option<String>,
    properties: Vec<PropertyContext>,
    type_refs: HashMap<String, String>,
}

#[derive(Serialize)]
struct PropertyContext {
    name: String,
    ts_type: String,
    optional: bool,
    description: Option<String>,
}

#[derive(Serialize)]
struct EnumContext {
    name: String,
    values: Vec<String>,
}

#[derive(Serialize)]
struct TypeContext {
    name: String,
    ts_type: String,
}

impl SchemaContext {
    fn from_schema(name: &str, schema: &Schema) -> Self {
        let mut properties = Vec::new();

        if let Schema::Object {
            properties: props, ..
        } = schema
        {
            for prop in props {
                properties.push(PropertyContext {
                    name: prop.name.clone(),
                    ts_type: schema_to_ts_type(&prop.schema(), &HashMap::new()),
                    optional: prop.optional,
                    description: prop.description.clone(),
                });
            }
        }

        Self {
            name: name.to_string(),
            description: None,
            properties,
            type_refs: HashMap::new(),
        }
    }
}

fn schema_to_ts_type(schema: &Schema, refs: &HashMap<String, String>) -> String {
    match schema {
        Schema::Null => "null".to_string(),
        Schema::Bool => "boolean".to_string(),
        Schema::Int8 | Schema::Int16 | Schema::Int32 | Schema::Int64 => "number".to_string(),
        Schema::UInt8 | Schema::UInt16 | Schema::UInt32 | Schema::UInt64 => "number".to_string(),
        Schema::Float32 | Schema::Float64 => "number".to_string(),
        Schema::String => "string".to_string(),
        Schema::Bytes => "Uint8Array".to_string(),

        Schema::Array { items, .. } => {
            format!("Array<{}>", schema_to_ts_type(items, refs))
        }

        Schema::Tuple { items } => {
            let types: Vec<_> = items.iter().map(|s| schema_to_ts_type(s, refs)).collect();
            format!("[{}]", types.join(", "))
        }

        Schema::Object { .. } => "Record<string, unknown>".to_string(),

        Schema::Union { any_of } => {
            if any_of.len() == 2 {
                let is_optional = any_of.iter().any(|s| matches!(s, Schema::Null));
                if is_optional {
                    let non_null: Vec<_> = any_of
                        .iter()
                        .filter(|s| !matches!(s, Schema::Null))
                        .collect();
                    if non_null.len() == 1 {
                        return format!("{} | null", schema_to_ts_type(non_null[0], refs));
                    }
                }
            }
            let types: Vec<_> = any_of.iter().map(|s| schema_to_ts_type(s, refs)).collect();
            types.join(" | ")
        }

        Schema::Literal { value } => match value {
            LiteralValue::String(s) => format!("'{}'", s),
            LiteralValue::Number(n) => format!("{}", n),
            LiteralValue::Float(f) => format!("{}", f),
            LiteralValue::Boolean(b) => format!("{}", b),
            LiteralValue::Null => "null".to_string(),
        },

        Schema::Enum { .. } => "string".to_string(),

        Schema::Ref { reference } => {
            let name = reference
                .strip_prefix("#/definitions/")
                .unwrap_or(reference);
            refs.get(name).cloned().unwrap_or_else(|| name.to_string())
        }

        Schema::Named { name, .. } => name.clone(),
    }
}

const MODULE_TEMPLATE: &str = r#"{{preamble}}{{#each schemas}}
{{{this}}}
{{/each}}"#;

const INTERFACE_TEMPLATE: &str = r#"{{#if description}}/** {{description}} */
{{/if}}export interface {{name}} {
{{#each properties}}
  {{#if description}}/** {{description}} */
  {{/if}}{{name}}{{#if optional}}?{{/if}}: {{ts_type}};
{{/each}}
}
"#;

const ENUM_TEMPLATE: &str = r#"export type {{name}} = {{#each values}}'{{this}}'{{#unless @last}} | {{/unless}}{{/each}};
"#;

const TYPE_TEMPLATE: &str = r#"export type {{name}} = {{ts_type}};
"#;

#[cfg(test)]
mod tests {
    use super::*;
    use crate::builder::SchemaBuilder;

    #[test]
    fn test_generate_interface() {
        let gen = TypeScriptGenerator::new();
        let schema = SchemaBuilder::object()
            .field("id", SchemaBuilder::int64())
            .field("name", SchemaBuilder::string())
            .optional_field("email", SchemaBuilder::string())
            .build();

        let output = gen.generate("Person", &schema).unwrap();
        assert!(output.contains("export interface Person"));
        assert!(output.contains("id: number"));
        assert!(output.contains("name: string"));
        assert!(output.contains("email?: string"));
    }

    #[test]
    fn test_generate_enum() {
        let gen = TypeScriptGenerator::new();
        let schema = SchemaBuilder::enum_values(vec!["Red", "Green", "Blue"]);

        let output = gen.generate("Color", &schema).unwrap();
        assert!(output.contains("export type Color"));
        assert!(output.contains("'Red'"));
        assert!(output.contains("'Green'"));
        assert!(output.contains("'Blue'"));
    }

    #[test]
    fn test_generate_module() {
        let gen = TypeScriptGenerator::new();
        let mut registry = SchemaRegistry::new();

        registry.register(
            "Person",
            SchemaBuilder::object()
                .field("id", SchemaBuilder::int64())
                .field("name", SchemaBuilder::string())
                .build(),
        );

        let output = gen.generate_module(&registry).unwrap();
        assert!(output.contains("// Auto-generated"));
        assert!(output.contains("export interface Person"));
    }
}
