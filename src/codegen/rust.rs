use crate::codegen::SchemaRegistry;
use crate::schema::{LiteralValue, Schema};
use handlebars::Handlebars;
use serde::Serialize;
use std::collections::HashMap;

pub struct RustGenerator {
    registry: Handlebars<'static>,
}

impl RustGenerator {
    pub fn new() -> Self {
        let mut registry = Handlebars::new();
        registry
            .register_template_string("module", MODULE_TEMPLATE)
            .unwrap();
        registry
            .register_template_string("struct", STRUCT_TEMPLATE)
            .unwrap();
        registry
            .register_template_string("enum", ENUM_TEMPLATE)
            .unwrap();

        Self { registry }
    }

    pub fn generate(&self, name: &str, schema: &Schema) -> Result<String, crate::Error> {
        let context = SchemaContext::from_schema(name, schema);

        match schema {
            Schema::Enum { values } => {
                let ctx = EnumContext {
                    name: name.to_string(),
                    values: values.clone(),
                };
                Ok(self.registry.render("enum", &ctx)?)
            }
            Schema::Object { .. } => Ok(self.registry.render("struct", &context)?),
            Schema::Named { schema, .. } => self.generate(name, schema),
            _ => {
                let rust_type = schema_to_rust_type(schema, &HashMap::new());
                Ok(format!("pub type {} = {};\n", name, rust_type))
            }
        }
    }

    pub fn generate_module(&self, registry: &SchemaRegistry) -> Result<String, crate::Error> {
        let mut rendered: Vec<String> = Vec::new();

        for (name, schema) in registry.schemas() {
            rendered.push(self.generate(name, schema)?);
        }

        let mut output = String::new();
        output.push_str("// Auto-generated by typebox-rs. DO NOT EDIT.\n\n");
        output.push_str("use serde::{Deserialize, Serialize};\n\n");

        for code in rendered {
            output.push_str(&code);
            output.push_str("\n");
        }

        Ok(output)
    }
}

impl Default for RustGenerator {
    fn default() -> Self {
        Self::new()
    }
}

#[derive(Serialize)]
struct SchemaContext {
    name: String,
    description: Option<String>,
    properties: Vec<PropertyContext>,
    type_refs: HashMap<String, String>,
}

#[derive(Serialize)]
struct PropertyContext {
    name: String,
    rust_name: String,
    rust_type: String,
    optional: bool,
    description: Option<String>,
    has_default: bool,
    default_value: Option<String>,
}

#[derive(Serialize)]
struct EnumContext {
    name: String,
    values: Vec<String>,
}

impl SchemaContext {
    fn from_schema(name: &str, schema: &Schema) -> Self {
        let mut properties = Vec::new();

        if let Schema::Object {
            properties: props, ..
        } = schema
        {
            for prop in props {
                properties.push(PropertyContext {
                    name: prop.name.clone(),
                    rust_name: format_ident(&prop.name),
                    rust_type: schema_to_rust_type(&prop.schema(), &HashMap::new()),
                    optional: prop.optional,
                    description: prop.description.clone(),
                    has_default: false,
                    default_value: None,
                });
            }
        }

        Self {
            name: name.to_string(),
            description: None,
            properties,
            type_refs: HashMap::new(),
        }
    }
}

fn schema_to_rust_type(schema: &Schema, refs: &HashMap<String, String>) -> String {
    match schema {
        Schema::Null => "()".to_string(),
        Schema::Bool => "bool".to_string(),
        Schema::Int8 => "i8".to_string(),
        Schema::Int16 => "i16".to_string(),
        Schema::Int32 => "i32".to_string(),
        Schema::Int64 => "i64".to_string(),
        Schema::UInt8 => "u8".to_string(),
        Schema::UInt16 => "u16".to_string(),
        Schema::UInt32 => "u32".to_string(),
        Schema::UInt64 => "u64".to_string(),
        Schema::Float32 => "f32".to_string(),
        Schema::Float64 => "f64".to_string(),
        Schema::String => "String".to_string(),
        Schema::Bytes => "Vec<u8>".to_string(),

        Schema::Array { items, .. } => {
            format!("Vec<{}>", schema_to_rust_type(items, refs))
        }

        Schema::Tuple { items } => {
            let types: Vec<_> = items.iter().map(|s| schema_to_rust_type(s, refs)).collect();
            format!("({})", types.join(", "))
        }

        Schema::Object { .. } => "serde_json::Value".to_string(),

        Schema::Union { any_of } => {
            if any_of.len() == 2 {
                let is_optional = any_of.iter().any(|s| matches!(s, Schema::Null));
                if is_optional {
                    let non_null: Vec<_> = any_of
                        .iter()
                        .filter(|s| !matches!(s, Schema::Null))
                        .collect();
                    if non_null.len() == 1 {
                        return format!("Option<{}>", schema_to_rust_type(non_null[0], refs));
                    }
                }
            }
            let types: Vec<_> = any_of
                .iter()
                .map(|s| schema_to_rust_type(s, refs))
                .collect();
            format!("({})", types.join(" | "))
        }

        Schema::Literal { value } => match value {
            LiteralValue::String(s) => format!("&'static str /* \"{}\" */", s),
            LiteralValue::Number(n) => format!("{}", n),
            LiteralValue::Float(f) => format!("{}", f),
            LiteralValue::Boolean(b) => format!("{}", b),
            LiteralValue::Null => "()".to_string(),
        },

        Schema::Enum { .. } => "String".to_string(),

        Schema::Ref { reference } => {
            let name = reference
                .strip_prefix("#/definitions/")
                .unwrap_or(reference);
            refs.get(name).cloned().unwrap_or_else(|| name.to_string())
        }

        Schema::Named { name, .. } => name.clone(),
    }
}

fn format_ident(name: &str) -> String {
    match name {
        "type" => "r#type".to_string(),
        "match" => "r#match".to_string(),
        "fn" => "r#fn".to_string(),
        "mod" => "r#mod".to_string(),
        "use" => "r#use".to_string(),
        s => s.to_string(),
    }
}

const MODULE_TEMPLATE: &str = r#"{{preamble}}
use serde::{Deserialize, Serialize};

{{#each schemas}}
{{{this}}}
{{/each}}
"#;

const STRUCT_TEMPLATE: &str = r#"#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct {{name}} {
{{#each properties}}
    {{#if description}}/// {{description}}
    {{/if}}{{#if optional}}#[serde(skip_serializing_if = "Option::is_none")]
    {{/if}}pub {{rust_name}}: {{#if optional}}Option<{{/if}}{{rust_type}}{{#if optional}}>{{/if}},
{{/each}}
}
"#;

const ENUM_TEMPLATE: &str = r#"#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum {{name}} {
{{#each values}}
    #[serde(rename = "{{this}}")]
    {{this}},
{{/each}}
}
"#;

#[cfg(test)]
mod tests {
    use super::*;
    use crate::builder::SchemaBuilder;

    #[test]
    fn test_generate_struct() {
        let gen = RustGenerator::new();
        let schema = SchemaBuilder::object()
            .field("id", SchemaBuilder::int64())
            .field("name", SchemaBuilder::string())
            .optional_field("email", SchemaBuilder::string())
            .build();

        let output = gen.generate("Person", &schema).unwrap();
        assert!(output.contains("pub struct Person"));
        assert!(output.contains("pub id: i64"));
        assert!(output.contains("pub name: String"));
        assert!(output.contains("pub email: Option<String>"));
    }

    #[test]
    fn test_generate_enum() {
        let gen = RustGenerator::new();
        let schema = SchemaBuilder::enum_values(vec!["Red", "Green", "Blue"]);

        let output = gen.generate("Color", &schema).unwrap();
        assert!(output.contains("pub enum Color"));
        assert!(output.contains("Red"));
        assert!(output.contains("Green"));
        assert!(output.contains("Blue"));
    }

    #[test]
    fn test_generate_module() {
        let gen = RustGenerator::new();
        let mut registry = SchemaRegistry::new();

        registry.register(
            "Person",
            SchemaBuilder::object()
                .field("id", SchemaBuilder::int64())
                .field("name", SchemaBuilder::string())
                .build(),
        );

        let output = gen.generate_module(&registry).unwrap();
        assert!(output.contains("use serde::{Deserialize, Serialize}"));
        assert!(output.contains("pub struct Person"));
    }
}
